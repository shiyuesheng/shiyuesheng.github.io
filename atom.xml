<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shiyuesheng.github.io</id>
    <title>玄戈大人</title>
    <updated>2021-04-02T06:28:34.952Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shiyuesheng.github.io"/>
    <link rel="self" href="https://shiyuesheng.github.io/atom.xml"/>
    <subtitle>垂露悬针聚墨藏锋的章法，书同南北交手相传漫天涯</subtitle>
    <logo>https://shiyuesheng.github.io/images/avatar.png</logo>
    <icon>https://shiyuesheng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 玄戈大人</rights>
    <entry>
        <title type="html"><![CDATA[方法引用被编译成了什么]]></title>
        <id>https://shiyuesheng.github.io/post/fang-fa-yin-yong-bei-bian-yi-cheng-liao-shi-me/</id>
        <link href="https://shiyuesheng.github.io/post/fang-fa-yin-yong-bei-bian-yi-cheng-liao-shi-me/">
        </link>
        <updated>2021-04-02T06:28:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>先进行总结，方便回顾：</p>
<p>lambda表达式同方法引用编译之后的基本一致，区别在于：</p>
<ul>
<li>lambda表达式会在声明类中生成私有静态方法，lambda表达式的业务逻辑也在其中</li>
<li>方法引用不会生成私有静态方法，引用的方法在动态生成的内部类中调用</li>
</ul>
</blockquote>
<p>有了之前编译lambda表达式的例子，这次废话不多说，直接开始。</p>
<h2 id="一个简单的例子">一个简单的例子</h2>
<pre><code class="language-java">public class LambdaTest {
    public String getName() {
        return &quot;9627&quot;;
    }
    public static void main(String[] args) {
        Function&lt;LambdaTest, String&gt; functionDemo = LambdaTest::getName;
    }
}
</code></pre>
<p>使用命令编译 javac -g LambdaTest.java</p>
<p>使用命令查看字节码 javap -v -p LambdaTest.class</p>
<pre><code class="language-java">public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=2, args_size=1
         0: invokedynamic #6,  0              // InvokeDynamic #0:apply:()Ljava/util/function/Function;
         5: astore_1
         6: return

BootstrapMethods:
  0: #41 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:
    Method arguments:
      #42 (Ljava/lang/Object;)Ljava/lang/Object;
      #43 invokevirtual suishen/redis/hash/mapping/test/LambdaTest.getName:()Ljava/lang/String;
      #44 (Lsuishen/redis/hash/mapping/test/LambdaTest;)Ljava/lang/String;
</code></pre>
<p>编译之后invokedynamic 指令跟之前编译lambda表达式一致，但是没有生成私有静态方法。</p>
<p>运行下看看生成的内部类：</p>
<p>执行命令 <strong>java -Djdk.internal.lambda.dumpProxyClasses TestLambda</strong></p>
<p>使用命令查看内部类的字节码 <strong>javap -v -p LambdaTest$$Lambda$1.class</strong></p>
<pre><code class="language-java">final class LambdaTest$$Lambda$1 implements Function {
    private LambdaTest$$Lambda$1() {
    }

    @Hidden
    public Object apply(Object var1) {
        return ((LambdaTest)var1).getName();
    }
}
</code></pre>
<p>简单分析下：</p>
<p>1、该内部类类名 LambdaTest$$Lambda$1</p>
<p>2、实现了函数式接口Function 的apply方法</p>
<p>3、apply方法内部对传入的参数进行强制类型转换，必须是LambdaTest类型的，符合预期</p>
<p>3、apply方法内部调用了，LambdaTest实例的getName()方法，LambdaTest实例来自调用方传入</p>
<h2 id="捕获变量的例子">捕获变量的例子</h2>
<pre><code class="language-java">public class LambdaTest {
    public Long toLong(String name) {
        return 9527L;
    }
    public static void main(String[] args) {
        LambdaTest lambdaTest = new LambdaTest();
        Function&lt;String, Long&gt; functionDemo = lambdaTest::toLong;
    }
</code></pre>
<pre><code class="language-java"> public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: getstatic     #6                  // Field lambdaTest:Lsuishen/redis/hash/mapping/test/LambdaTest;
         3: dup
         4: invokevirtual #7                  // Method java/lang/Object.getClass:()Ljava/lang/Class;
         7: pop
         8: invokedynamic #8,  0              // InvokeDynamic #0:apply:(Lsuishen/redis/hash/mapping/test/LambdaTest;)Ljava/util/function/Function;
        13: astore_1
        14: return
BootstrapMethods:
  0: #44 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:
    Method arguments:
      #45 (Ljava/lang/Object;)Ljava/lang/Object;
      #46 invokevirtual suishen/redis/hash/mapping/test/LambdaTest.toLong:(Ljava/lang/String;)Ljava/lang/Long;
      #47 (Ljava/lang/String;)Ljava/lang/Long;
</code></pre>
<pre><code class="language-java">final class LambdaTest$$Lambda$1 implements Function {
    private final LambdaTest arg$1;
    private LambdaTest$$Lambda$1(LambdaTest var1) {
        this.arg$1 = var1;
    }
    private static Function get$Lambda(LambdaTest var0) {
        return new LambdaTest$$Lambda$1(var0);
    }
    @Hidden
    public Object apply(Object var1) {
        return this.arg$1.toLong((String)var1);
    }
}
</code></pre>
<p>我们只关注下最终生成的内部类，简单分析下：</p>
<p>1、该内部类类名 LambdaTest$$Lambda$1，</p>
<p>2、实现了函数式接口Function 的apply方法</p>
<p>3、内置了一个<strong>Field private final LambdaTest arg$1</strong> 这个实例属性在运行期动态调用，进行内部类实例化时，捕获自声明类上下文中的变量</p>
<p>4、apply方法内部调用了，arg$1.toLong(String)，参数来自调用方传入</p>
<h3 id="总结">总结：</h3>
<h4 id="1-lambda表达式同方法引用编译之后的基本一致区别在于">1、lambda表达式同方法引用编译之后的基本一致，区别在于：</h4>
<ul>
<li>lambda表达式会在声明类中生成私有静态方法，lambda表达式的业务逻辑也在其中</li>
<li>方法引用不会生成私有静态方法，引用的方法在动态生成的内部类中调用</li>
</ul>
<h4 id="2-方法引用-方法引用主体是方法已经定义好的方法逻辑都在方法中下游逻辑只管调用就好了-这也算是区别于lambda表达式地方吧逻辑代码块-code-所以lambda表达式的代码块在编译期中原封不动的放在了生成的私有静态方法中也算是有所归属-感觉像是编译期人为的向方法引用靠拢以期在运行期动态调用时达成共性的逻辑啊这一大段纯属猜测看个乐觉得有用就当是抛砖引玉了">2、方法引用、方法引用，主体是方法，已经定义好的方法，逻辑都在方法中，下游逻辑只管调用就好了。这也算是区别于lambda表达式地方吧（逻辑代码块 {code....} ），所以lambda表达式的代码块在编译期中原封不动的放在了生成的私有静态方法中，也算是有所归属。感觉像是编译期人为的向方法引用靠拢，以期在运行期动态调用时达成共性的逻辑（啊这一大段纯属猜测，看个乐，觉得有用，就当是抛砖引玉了）</h4>
<ul>
<li>不存在捕获变量：没有对象实体，下游逻辑传入对象实例，调用方法。</li>
<li>存在捕获变量：存在对象实体，下游逻辑传入方法所需参数，调用方法。</li>
</ul>
<h2 id="疑问-胡天扯地">疑问-胡天扯地</h2>
<pre><code class="language-java">private final static LambdaTest lambdaTest = new LambdaTest();
LambdaTest.lambdaTest::toLong
</code></pre>
<p>LambdaTest.lambdaTest 是私有静态属性，类似这样的方法引用也是存在捕获变量的，意味着每次调用都会生成一个新的内部类实例，但是此时捕获的变量 LambdaTest.lambdaTest 是不可变的。</p>
<p>个人觉得此种情况可以不用捕获变量，生成的内部类中，直接在方法体中嵌入这个对象，每次调用也不用生成新的内部类实例。</p>
<p><strong>一</strong>是我草率了，因为毕竟是猜测，在我的知识盲区，可能有不能这么处理的原因。</p>
<p><strong>二</strong>是官方目前没做优化，但是将来可能会对这种情况有优化？毕竟动态调用模式非常灵活，jvm内部的策略升级对我们是透明无感知的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lambda表达式被编译成了什么]]></title>
        <id>https://shiyuesheng.github.io/post/lambda-biao-da-shi-bei-bian-yi-cheng-liao-shi-me/</id>
        <link href="https://shiyuesheng.github.io/post/lambda-biao-da-shi-bei-bian-yi-cheng-liao-shi-me/">
        </link>
        <updated>2021-04-02T06:26:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="lambda表达式被编译成了什么">Lambda表达式被编译成了什么</h1>
<blockquote>
<p>先进行总结，方便回顾：</p>
<ul>
<li>
<p>编译时</p>
<ul>
<li>Lambda表达式会在当前的声明类中生成一个私有静态方法， 方法实现了Lambda表达式的代码逻辑</li>
</ul>
</li>
<li>
<ul>
<li>生成invokedynamic指令， 调用bootstrap methods， 由java.lang.invoke.LambdaMetafactory.metafactory方法实现</li>
</ul>
</li>
<li>
<p>运行时</p>
</li>
<li>
<ul>
<li>invokedynamic指令调用metafactory方法。它会返回一个CallSite, 此CallSite返回目标类型的一个匿名实现类， 此类内部关联编译时生成的私有静态方法</li>
<li>lambda表达式进行传递时，传递的是生成的内部类实例。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="一个简单的例子">一个简单的例子</h2>
<pre><code class="language-java">public class LambdaTest {
    public static final LambdaTest lambdaTest = new LambdaTest();
    public String getName() {
        return &quot;9627&quot;;
    }
    public static void main(String[] args) {
        Function&lt;?, String&gt; functionDemo = s -&gt; LambdaTest.lambdaTest.getName();
    }
}
</code></pre>
<p>使用命令编译 javac -g LambdaTest.java   （此时并没有生成内部类class文件）</p>
<p>使用命令查看字节码 javap -v -p LambdaTest.class	（编译的文件过大，已屏蔽掉干扰信息，只关注lambda相关信息）</p>
<pre><code class="language-java">public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=2, args_size=1
         0: invokedynamic #6,  0              // InvokeDynamic #0:apply:()Ljava/util/function/Function;
         5: astore_1
         6: return

private static java.lang.String lambda$main$0(java.lang.Object);
    descriptor: (Ljava/lang/Object;)Ljava/lang/String;
    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
    Code:
      stack=1, locals=1, args_size=1
         0: getstatic     #7                  // Field lambdaTest:Lsuishen/redis/hash/mapping/test/LambdaTest;
         3: invokevirtual #8                  // Method getName:()Ljava/lang/String;
         6: areturn
         
BootstrapMethods:
  0: #46 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(此处方法签名描述省略)
    Method arguments:
      #47 (Ljava/lang/Object;)Ljava/lang/Object;
      #48 invokestatic suishen/redis/hash/mapping/test/LambdaTest.lambda$main$0:(Ljava/lang/Object;)Ljava/lang/String;
      #49 (Ljava/lang/Object;)Ljava/lang/String;
</code></pre>
<h3 id="invokedynamic-指令">invokedynamic 指令</h3>
<p>可以看到例子中的lambda表达式   <code>s -&gt; LambdaTest.lambdaTest.getName()</code> 编译后生成了 invokedynamic 指令，<code>#6</code>定位到常量池中下面的记录。</p>
<p>​			<em>#6 = InvokeDynamic      #0:#50         // #0:apply:()Ljava/util/function/Function;</em></p>
<p>其中 <code>#0</code> 指向的 BootstrapMethods 区的静态工厂方法   <code>java.lang.invoke.LambdaMetafactory.metafactory</code></p>
<p>LambdaMetafactory.metafactory()方法会利用asm字节码框架为 lambda表达式生成内部类，底层细节，此处不做深究。</p>
<h3 id="私有静态方法">私有静态方法</h3>
<p>编译后的class多了一个私有静态方法， LambdaTest.lambda$main$0(Object),尝试将字节码翻译成java代码，如下：</p>
<pre><code class="language-java">private static java.lang.String lambda$main$0(Object o) {
		return LambdaTest.LambdaTest.getName();
}
</code></pre>
<p>方法逻辑跟栗子中的lambda逻辑一致。</p>
<p>编译期间未看到生成的相关内部类。</p>
<h2 id="运行lambda">运行Lambda</h2>
<p>执行命令 <strong>java -Djdk.internal.lambda.dumpProxyClasses TestLambda</strong></p>
<p>运行结束后会在同级目录生成一个内部类的class文件   <strong>LambdaTest$$Lambda$1.class</strong></p>
<p>使用命令查看内部类的字节码 <strong>javap -v -p LambdaTest$$Lambda$1.class</strong>，也可以在idea中直接打开查看，此处直观的展示了idea反编译后的内容</p>
<pre><code class="language-java">final class LambdaTest$$Lambda$1 implements Function {
    private LambdaTest$$Lambda$1() {
    }
  
    @Hidden
    public Object apply(Object var1) {
        return LambdaTest.lambda$main$0(var1);
    }
}
</code></pre>
<p>简单分析下：</p>
<p>1、该内部类类名 LambdaTest$$Lambda$1，</p>
<p>2、实现了函数式接口Function 的apply方法，</p>
<p>3、方法内部调用的上文提到的，该内部类所在的声明类，编译后所生成的私有静态方法。LambdaTest.lambda$main$0(Object)</p>
<p>到这，就可以把lambda运行逻辑串联起来了。</p>
<ul>
<li>编译时lambda表达式会在当前声明类，生成一个私有静态方法，该方法逻辑与lambda逻辑相同。</li>
<li>运行时动态的使用asm字节码工具生成一个实现了目标函数式接口的内部类。</li>
<li>内部类进行实例化，方法间传递的是内部类的实例</li>
<li>调用内部类实例的函数式接口方法（SAM Single Abstract Method）</li>
<li>内部继续调用了声明类的私有静态方法，执行我们编写的真正的lambda表达式逻辑</li>
</ul>
<h2 id="捕获变量的例子">捕获变量的例子</h2>
<p>在匿名内部类中调用外部参数时，参数必须声明为final。</p>
<p>Lambda表达式内也可以引用上下文中的变量，称之为捕获变量、捕获参数。</p>
<p>Lambda表达式内捕获的外部变量，可以不声明为final类型，但是上下文语义中必须等同与final，也就是在后续逻辑中不可修改。</p>
<p>同样的一个简单的例子，lambda表达式 <code>s -&gt; lambdaTest.getName()</code>捕获了上下文中的变量 lambdaTest。</p>
<pre><code class="language-java">public class LambdaTest {
    public String getName() {
        return &quot;9627&quot;;
    }
    public static void main(String[] args) {
        LambdaTest lambdaTest = new LambdaTest();
        Function&lt;?, String&gt; functionDemo = s -&gt; lambdaTest.getName();
    }
}
</code></pre>
<p>使用命令编译 javac -g LambdaTest.java</p>
<p>使用命令查看字节码 javap -v -p LambdaTest.class</p>
<pre><code class="language-java">public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: new           #6                  // class suishen/redis/hash/mapping/test/LambdaTest
         3: dup
         4: invokespecial #7                  // Method &quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: aload_1
         9: invokedynamic #8,  0              // InvokeDynamic #0:apply:(Lsuishen/redis/hash/mapping/test/LambdaTest;)Ljava/util/function/Function;
        14: astore_2
        15: return

private static java.lang.String lambda$main$0(suishen.redis.hash.mapping.test.LambdaTest, java.lang.Object);
    descriptor: (Lsuishen/redis/hash/mapping/test/LambdaTest;Ljava/lang/Object;)Ljava/lang/String;
    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
    Code:
      stack=1, locals=2, args_size=2
         0: aload_0
         1: invokevirtual #9                  // Method getName:()Ljava/lang/String;
         4: areturn
BootstrapMethods:
  0: #45 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(此处方法签名描述省略)
    Method arguments:
      #46 (Ljava/lang/Object;)Ljava/lang/Object;
      #47 invokestatic suishen/redis/hash/mapping/test/LambdaTest.lambda$main$0:(Lsuishen/redis/hash/mapping/test/LambdaTest;Ljava/lang/Object;)Ljava/lang/String;
      #48 (Ljava/lang/Object;)Ljava/lang/String;
</code></pre>
<h3 id="私有静态方法-2">私有静态方法</h3>
<p>尝试将字节码翻译成java代码，看下区别在哪里。</p>
<pre><code class="language-java">private static java.lang.String lambda$main$0(LambdaTest lambdaTest, Object o) {
		return lambdaTest.getName();
}
</code></pre>
<p>方法逻辑跟栗子中的lambda逻辑一致。但是方法参数多了一个LambdaTest lambdaTest。</p>
<h3 id="内部类">内部类</h3>
<p>执行命令 <strong>java -Djdk.internal.lambda.dumpProxyClasses TestLambda</strong></p>
<p>使用命令查看内部类的字节码 <strong>javap -v -p LambdaTest.class</strong>，也可以在idea中直接打开查看，此处直观的展示了idea反编译后的内容</p>
<pre><code class="language-java">final class LambdaTest$$Lambda$1 implements Function {
    private final LambdaTest arg$1;

    private LambdaTest$$Lambda$1(LambdaTest var1) {
        this.arg$1 = var1;
    }

    private static Function get$Lambda(LambdaTest var0) {
        return new LambdaTest$$Lambda$1(var0);
    }

    @Hidden
    public Object apply(Object var1) {
        return LambdaTest.lambda$main$0(this.arg$1, var1);
    }
}
</code></pre>
<p>简单分析下：</p>
<p>1、该内部类类名 LambdaTest$$Lambda$1，</p>
<p>2、实现了函数式接口Function 的apply方法，</p>
<p>3、内置了一个<strong>Field private final LambdaTest arg$1</strong> 这个实例属性在运行期动态调用，进行内部类实例化时，捕获自声明类上下文中的变量</p>
<p>4、函数式接口方法内部调用的上文提到的私有静态方法，同时传入捕获的变量。前后呼应。</p>
<p>梳理下存在捕获变量的lambda流程：</p>
<ul>
<li>编译时lambda表达式会在当前声明类，生成一个私有静态方法，该方法逻辑与lambda逻辑相同。如果lambda表达式有捕获变量，则方法会多出与对应类型的参数。</li>
<li>运行时动态的使用asm字节码工具生成一个实现了目标函数式接口的内部类。如果lambda表达式有捕获变量，则内部类中会多出与之对应的属性。（<em><strong>此处大胆假设，因为不管执行多少次，生成的内部类class都是一样的，所以运行时应该会优化成只执行一次</strong></em>）</li>
<li>内部类进行实例化，方法间传递的是内部类的实例。（<em><strong>此处大胆假设，因为捕获了上下文中的变量，而这个变量在运行时是变化的，不确定的，所以每次调用都生成的新的内部类实例</strong></em>）</li>
<li>调用内部类实例的函数式接口方法（SAM Single Abstract Method）</li>
<li>内部继续调用了声明类的私有静态方法，执行我们编写的真正的lambda表达式逻辑</li>
</ul>
<h2 id="重复的lambda表达式">重复的Lambda表达式</h2>
<h3 id="多个长得一样的lambda表达式">多个长得一样的lambda表达式</h3>
<pre><code class="language-java">public static void main(String[] args) {
    LambdaTest lambdaTest = new LambdaTest();
    Function&lt;?, String&gt; functionDemo = s -&gt; lambdaTest.getName();
    Function&lt;?, String&gt; functionDemo1 = s -&gt; lambdaTest.getName();
}

</code></pre>
<ul>
<li>
<p>编译后会生成两个invokedynamic命令，两个私有静态方法</p>
</li>
<li>
<p>运行时会生成两个内部类class</p>
</li>
</ul>
<h3 id="循环同一个lambda表达式">循环同一个lambda表达式</h3>
<pre><code class="language-java">public static void main(String[] args) {
    LambdaTest lambdaTest = new LambdaTest();
    for (int i = 0; i &lt; 10; i++) {
        Function&lt;?, String&gt; functionDemo = s -&gt; lambdaTest.getName();
    }
}

</code></pre>
<ul>
<li>
<p>编译后会生成一个invokedynamic命令，一个私有静态方法</p>
</li>
<li>
<p>运行时会生成一个内部类class</p>
</li>
</ul>
<h2 id="测试生成的实例是否相同">测试生成的实例是否相同</h2>
<h3 id="不存在捕获变量">不存在捕获变量</h3>
<pre><code class="language-java">public final static LambdaTest lambdaTest = new LambdaTest();
public static void main(String[] args) {
    LambdaTest lambdaTest = LambdaTest.lambdaTest;
    for (int i = 0; i &lt; 5; i++) {
        Function&lt;?, String&gt; functionDemo = s -&gt; LambdaTest.lambdaTest.getName();
        System.out.println(functionDemo);
    }
}
打印信息：
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@4cdf35a9
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@4cdf35a9
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@4cdf35a9
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@4cdf35a9
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@4cdf35a9

</code></pre>
<p>生成的实例是相同的。</p>
<h3 id="存在捕获变量">存在捕获变量</h3>
<pre><code class="language-java">public final static LambdaTest lambdaTest = new LambdaTest();
public static void main(String[] args) {
    LambdaTest lambdaTest = new LambdaTest();
    for (int i = 0; i &lt; 5; i++) {
        Function&lt;?, String&gt; functionDemo = s -&gt; lambdaTest.getName();
        System.out.println(functionDemo);
    }
}
打印信息：
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@45fe3ee3
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@4cdf35a9
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@4c98385c
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@5fcfe4b2
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@6bf2d08e

</code></pre>
<p>生成的实例是不同的</p>
<h3 id="存在捕获变量捕获变量是类的静态属性">存在捕获变量，捕获变量是类的静态属性</h3>
<pre><code class="language-java">public final static LambdaTest lambdaTest = new LambdaTest();
public static void main(String[] args) {
    LambdaTest lambdaTest = LambdaTest.lambdaTest;
    for (int i = 0; i &lt; 5; i++) {
        Function&lt;?, String&gt; functionDemo = s -&gt; lambdaTest.getName();
        System.out.println(functionDemo);
    }
}
打印信息：
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@45fe3ee3
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@4cdf35a9
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@4c98385c
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@5fcfe4b2
suishen.redis.hash.mapping.test.LambdaTest$$Lambda$1/1973336893@6bf2d08e

</code></pre>
<p>生成的实例是不同的</p>
<h3 id="总结">总结：</h3>
<ul>
<li>如果不存在捕获变量，每次调用生成的实例是相同的</li>
<li>如果存在捕获变量，每次调用生成的实例是不相同的</li>
</ul>
<p>与猜想一致，以上。</p>
<blockquote>
<p><em>来自网络</em></p>
<h1 id="lambda表达式的转换策略">Lambda表达式的转换策略</h1>
<p>Brian Goetz是Oracle的Java语言架构师， JSR 335(Lambda Expression)规范的lead, 写了几篇Lambda设计方面的文章， 其中之一就是Translation of Lambda Expressions。这篇文章介绍了Java 8 Lambda设计时的考虑以及实现方法。</p>
<p>他提到， Lambda表达式可以通过内部类， method handle, dynamic proxy等方式实现， 但是这些方法各有优劣。真正要实现Lambda表达式， 必须兼顾两个目标：一是不引入特定策略，以期为将来的优化提供最大的灵活性， 二是保持类文件格式的稳定。通过Java 7中引入的<strong>invokedynamic</strong> （JSR 292）, 可以很好的兼顾这两个目标。</p>
<p><strong>invokedynamic</strong> 在缺乏静态类型信息的情况下可以支持有效的灵活的方法调用。主要是为了日益增长的运行在JVM上的动态类型语言， 如Groovy, JRuby。</p>
<p><strong>invokedynamic</strong> 将Lambda表达式的转换策略推迟到运行时， 这也意味着我们现在编译的代码在将来的转换策略改变的情况下也能正常运行。</p>
<p>编译器在编译的时候， 会将Lambda表达式的表达式体 (lambda body)脱糖(desugar) 成一个方法，此方法的参数列表和返回类型和lambda表达式一致， 如果有捕获参数， 脱糖的方法的参数可能会更多一些， 并会产生一个<strong>invokedynamic</strong>调用， 调用一个call site。（如果是一个方法引用的话，会进行不一样的处理，不会脱糖成静态方法，而是将方法调用写入了生成的内部类中）</p>
<p>这个call site被调用时会返回lambda表达式的目标类型(functional interface)的一个实现类。这个call site称为这个lambda表达式的<em>lambda factory</em>。 <em>lambda factory</em>的bootstrap方法是一个标准方法， 叫做<em>lambda metafactory</em>。</p>
<p>编译器在转换lambda表达式时， 可以推断出表达式的参数类型，返回类型以及异常， 称之为<code>natural signature</code>， 我们将目标类型的方法签名称之为<code>lambda descriptor</code>, lambda factory的返回对象实现了函数式接口， 并且关联的表达式的代码逻辑， 称之为<code>lambda object</code>。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试]]></title>
        <id>https://shiyuesheng.github.io/post/ce-shi/</id>
        <link href="https://shiyuesheng.github.io/post/ce-shi/">
        </link>
        <updated>2020-11-02T03:43:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="北京">北京</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《后浪》别酸了--抄录]]></title>
        <id>https://shiyuesheng.github.io/post/lesslesshou-lang-greatergreater-bie-suan-liao-chao-lu/</id>
        <link href="https://shiyuesheng.github.io/post/lesslesshou-lang-greatergreater-bie-suan-liao-chao-lu/">
        </link>
        <updated>2020-06-14T13:04:21.000Z</updated>
        <content type="html"><![CDATA[<p>最近《后浪》视频出来这几天，一直都有不少争议。</p>
<p>视频里所展现出的异国出游、自由探索等状态，戳到了很多人的痛处，有人酸“这是给富人阶层拍的片子”，还有人为“视频是否暴露出阶级差异”展开各种争论。</p>
<p>网上产生种种争议声音的原因，概括一下，主要还是源自一些人产生的三大错觉。</p>
<h4 id="1-世界三大错觉">1、世界三大错觉</h4>
<p>普通人的错觉之一，是以为有钱人、领导们的钱都是不劳而获，每天轻松躺着挣钱。仿佛他们说句话、挥挥手，几百几千万就轻松到账。</p>
<p>典型如带货主播李佳琦薇娅，曾经有很多人眼红他们说话就能挣钱，觉得这钱太好挣了。</p>
<p>但实际上，他们付出的努力与辛苦，是很多人都做不到的。很多真正做过直播的朋友，都曾感慨过直播真的太难，体力与毅力完全不是一般人所能承受。</p>
<p>而那些被人们所羡慕的上市公司CEO或高管，每天更是忙到脚不离地，晚上需要各种开会，一开就要几个小时，大部分的时间都要熬夜。</p>
<p>虽然高管基本是每个月都出国出差、经常吃米其林餐厅，但生活内容都是见客户、商务谈判，基本没有太多时间去享受。</p>
<p>就像朱一旦的描述，真的是非常枯燥。</p>
<p>如果把你放在他们的位置上，你也未必喜欢这样的生活，更不会羡慕。</p>
<p>你只会感觉比底层社畜的时候更高压，更劳累，很难承受这样的工作压力和工作节奏。</p>
<p>但是，人们永远只能看到成功者的光鲜，却自动忽略他们的辛苦。</p>
<p>要记住这个道理：</p>
<p>操多大的心，拼多大的命，赚多大的钱；</p>
<p>赚多大的钱，实现多大的野心，享受多高的生活质量。</p>
<p>都是因果相关，完全不存在什么捷径，更不存在轻松挣钱的方式。</p>
<p>如果非要追求活少钱多，建议直接做梦。</p>
<p>人们的错觉之二，是以为自己每天996还挣不到钱，都是因为黑心资本家剥削克扣。</p>
<p>不排除有这样的可能，但并非所有的资本家都黑心，都是在剥削你。</p>
<p>很多奋斗的人说自己现在过得太苦，可问题是，除了富N代，那些白手起家的人，谁刚入社会不是苦过来的？</p>
<p>吃苦不算什么，重要的是如何将这种苦更快的度过去，而不是在苦难中一味散发戾气。</p>
<p>抱怨解决不了任何现实问题。</p>
<p>要知道，你的收入，永远是跟能力与勤奋成正比的。</p>
<p>首先，99%的职场人，扪心自问，都未必做到了勤奋这一点。</p>
<p>其次，如果你觉得自己真的很勤奋，经历各种996却还是收入很低，那就需要警惕，你的努力是否有效率，是否还是劣质的努力，或者，努力的行业是否真的适合自己。</p>
<p>再进一步，如果方向没问题的话，是不是自己的职场能力还比较薄弱。</p>
<p>要一步一步去反思自己，去改变。</p>
<p>当然，生活中难免会遇到很多不公平的事情，那就尽最大所能，先改变自己目前能够改变的。</p>
<p>人们的错觉之三，是认为自己从一开始就出身在普通或贫困家庭，无论怎么努力，也比不上那些富二代。</p>
<p>觉得在阶级固化之下，在巨大的成就背后，身世更重要，个人的奋斗微不足道，就开始质疑奋斗的意义，于是开始犬儒、开始懈怠。</p>
<p>这样的人，其实从一开始的比较目标就设错了。</p>
<p>你成不成功，跟时代没有必然关系。</p>
<p>而且无论在哪个时代，排除个别极端的例子，个人想实现阶层跃迁都非常难。</p>
<p>就算是把你放在下海创业机会多的八九十年代，互联网初创公司蓬勃兴起的千禧年代。</p>
<p>要承认的是，该是炮灰一样是炮灰，你大概率成不了潘石屹，也做不了张一鸣。</p>
<p>然而，当不了马云们，奋斗就没意义了么？这一辈子就人间失格了么？</p>
<p>当然不是。</p>
<p>我们的奋斗，是为了更好的生活，而这个“更好”的比较，是基于自己。</p>
<p>不是非得在一线城市扎根、或能将奢侈品当作日用品的生活，才能叫做“更好的生活”。</p>
<p>实际上，基于每个人的初始情况不同，从农村到县城、从县城到城市，从三四线城市到一线，每一个改变，都是提升，也是个人奋斗的成果。</p>
<p>至于提升的幅度与空间，则跟你的努力程度息息相关。</p>
<p>在现实中，也有很多如你我一样的普通人，通过奋斗，如今都过上当初想要的生活的例子。</p>
<p>他们“实现更好的生活”有各种原因，但最关键的因素，无一例外，还是比一般人多出几倍的勤奋。</p>
<p>同样，我也见过一些富二代，一毕业后就选择待在国企，拿着微薄的薪水，因为没有上进心，能力不足，在国企辞职以后，在市场上找工作也一样费力，完全不存在什么富二代光环。</p>
<p>所以，那些拿家世作为挡箭牌，通过一句“阶级固化”粉饰自己不够勤奋的现实，完全是一部分人的自我欺骗而已。</p>
<h4 id="2-割韭菜的意义滥用">2、“割韭菜”的意义滥用</h4>
<p>这几年因为李笑来、罗永浩等人身体力行的科普，成功让大众知道了韭菜这个词。</p>
<p>“韭菜”一词这几年也快速实现下沉，让县城农村的人都知道是什么意思。</p>
<p>同时，这也给很多人一种错觉，仿佛任何东西只要跟钱沾上了边，那就是在收割自己，就是在割韭菜，仿佛“全世界都在害他”一样。</p>
<p>这就要回到割韭菜的定义，到底什么是割韭菜。</p>
<p>具体指的是，卖方提供的东西，是假的、完全不足以匹配价格的，欺骗了买方，这才叫割韭菜。</p>
<p>其余情况，只要对方付出了服务与商品，并得到双方都默认同意的回报，这些都属于正常的交易关系，你情我愿而已。</p>
<p>不要看到旅游博主、美食博主很能挣钱，就觉得他一定是在割韭菜，实际上，像李子柒这样的博主，背后付出的辛苦程度远非一般人能承受了的：</p>
<p>重复的枯燥拍摄、创作的孤独、远比一般人要少太多的娱乐休闲......可以说，他们通过牺牲自己，才制造出了精致的视频，为看客们造梦。</p>
<p>多大的付出，就有多大的回报，真没什么好酸的。</p>
<p>一物换一物，这是商业社会的本质。</p>
<p>如果实在看不过去，那就去修炼自己，牺牲自己，把自己变成镰刀，成为卖方去服务（收割）别人，多向别人提供服务。</p>
<p>而不是每天纯粹当消费者，享受他人的劳动成果，完了还一脸受害者的样子。</p>
<p>最后想说一点，我写文的意思，不是要鼓励所有人都要为了工作放弃娱乐，也不是鼓吹所有人都非要成为事业强人。</p>
<p>那些放低人生欲望、平平淡淡在小城市过好一生的选择，也同样值得尊重。</p>
<p>毕竟，每种选择都有代价，也都有优势，如何选择只是因人而异。</p>
<p>但最重要的是，不要老是想着好处全占、代价全免。</p>
<p>一边又想享受普通人“活在当下”的生活，一边又想着做出一番事业实现阶级跃升，最后野心实现不了，就开始怪阶级固化的大环境。</p>
<p>这样的人，非贪即坏，最后什么也得不到。</p>
<p>所以，对于一部分人来说，与其酸、质疑《后浪》，不如把这个时间与精力花在怎么做好手头工作、提升自己上。</p>
<p>务实一点吧，“后浪”们！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《后浪》刺激了谁的神经？--抄录]]></title>
        <id>https://shiyuesheng.github.io/post/lesslesshou-lang-greatergreater-ci-ji-liao-shui-de-shen-jing/</id>
        <link href="https://shiyuesheng.github.io/post/lesslesshou-lang-greatergreater-ci-ji-liao-shui-de-shen-jing/">
        </link>
        <updated>2020-06-14T13:02:19.000Z</updated>
        <content type="html"><![CDATA[<p>五四前夕， 后浪登入央视黄金档，引起众多人关注。随后不久，B站也上线了，迅速占据了热搜榜。电视网络的全贯通，加之社交媒体的发酵，传播力和影响力都达到了巅峰。<br>
我的朋友圈人很少，即使发生重大新闻事件，也平静如水，少有人讨论。可是这次，连续四五条转发，还配上了自己的感悟。<br>
我应该是后浪的第一批观众了，那时候看得热血沸腾，完全被情绪给代入了，搭配着不断增加的弹幕，看了一遍又一遍。<br>
下面的评论，在我的眼皮底下，从几百条涨到三千多条，网友基本是正面的态度，感叹国家进步和受到鼓励的居多。<br>
不过，让我惊讶的是，到了五四当天，全网风向大变，正面评论早已淹没在批判声中。对比了评论雷同的内容和发布的时段，发现知乎起到了重要作用。<br>
高赞者无不挑刺鄙视，说这只照顾了少数的衣食无忧之人，大多数年轻人在底层垂死挣扎的现状，却没有看到。也有人说，后浪是给“前浪”看的，有阿谀奉承之嫌。甚至有说，这是发令枪，以便继续剥削。这些质疑，戳到了年轻人的痛点，产生了内心的共鸣。<br>
在碎片化的网络时代，思考成为了最稀缺的产品。人们喝腻了白鸡汤，嫌弃鄙夷，觉得智商被侮辱了；于是有人在白鸡汤中，放了些调料，变成了黑鸡汤，于是觉得天下美味，到处炫耀思想高人一等。<br>
看看那些知乎获得高赞的人吧，被专业领域的回答者、高学历人群和公众号写手垄断了，他们心思缜密，可以侃侃而谈，他们很明白，你们这些底层想要什么，既然给不了正面前进的支撑，就给你宣泄情感的出口。<br>
呵呵，一来一回，又回到了培养韭菜割韭菜的老套路罢了。他们口口声声说，后浪只照顾了城市小资甚至是特权阶级，但反过来要问，你们这些知乎人，又能代表底层阶级吗？<br>
腹黑一点说，这些人早已挣脱了底层，正在赶往上层的路上，为了加速往前冲，需要借助底层的力量，有时发现困难重重，就认为上层人在阻碍他，前方破口大骂，后方惺惺作态，制造严重的对立。<br>
说白了，这场由后浪引起的舆论风波，是一场未来的准上层，带动不明真相的底层，来打击传统上层的斗争罢了。底层收获了精神的安慰，准上层收获了上升的曙光，B站也获得了流量，谁赢谁输自己比较。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《后浪》刺激了谁的自尊？--抄录]]></title>
        <id>https://shiyuesheng.github.io/post/lesslesshou-lang-greatergreater-ci-ji-liao-shui-de-zi-zun/</id>
        <link href="https://shiyuesheng.github.io/post/lesslesshou-lang-greatergreater-ci-ji-liao-shui-de-zi-zun/">
        </link>
        <updated>2020-06-14T12:57:13.000Z</updated>
        <content type="html"><![CDATA[<p>5月3日（五四青年节前夕），B站推出了一段名为《后浪》的演讲视频。国家一级演员“老戏骨”何冰作为片中的主讲者，以充满力量的言语张力，向年轻人表达了自己作为“前浪”对“后浪”的羡慕、憧憬和希翼。如此鸡汤的视频，刚一播出，就获得了网友们的纷纷转载。</p>
<p>不过，凡事都有两面，《后浪》上千万的播放量背后，有赞誉，也招来了许多的恶评。而作为片中的演讲者何冰，也没能逃过一劫，同样被推到了风口浪尖。一时间，各种谩骂、讽刺话语铺天盖地袭来，何冰微博几乎被攻陷。最后，何冰因为这次演讲，被6000+条恶评推上了热搜。</p>
<p>这也足于让人看到了什么是人言可畏。</p>
<p>何冰为何被骂“晚节不保”？《后浪》到底刺痛了谁的自尊？</p>
<p>客观上说，《后浪》的视频演讲是富有激情和感染力的。短片在B站首播不久，其浏览量就高达1783万，可见其内容的影响力。</p>
<p>但为何明明是一个正能量的励志演讲（短片），收到的却是数千上万条的恶语批判呢？</p>
<p>对此，有人直言不讳地指出：《后浪》短片是拍给富人看的，镜头里的年轻人，并不代表真实世界里的所有年轻人。</p>
<p>“你见过谁家孩子都能拥有如此优越的生活条件，拿着上万、几十万的现代高科技设备去记录生活，无所顾虑到处去旅行，看世界……”</p>
<p>有网友答复说：“我从未见过VR眼镜，也从未坐过飞机，更别说出国旅行，购买几万、几十万的高科技摄影设备了……”</p>
<p>的确，这正如2019年中泰证券研究所所长李迅雷总结所言，我们的实际情况是：中国还有10亿人没坐过飞机，至少有一半以上的家庭迄今没有用上抽水马桶。</p>
<p>而这些仅仅是小范围中的冰山一角而已。</p>
<p>这世界，80%的资源掌握在20%的人手中，这世界，富人只占了极少部分。现在的大多数的年轻人，更多的是要面对无钱买房的压力，夜夜加班的压力，不敢结婚的压力……</p>
<p>当一个人连基本的生存问题都尚未解决时，还能拿什么来谈理想？</p>
<p>正如有网友反问所言：“你见过大凉山的那些可怜的孩子吗？你以为想“浪”就能“浪”吗？”</p>
<p>“《后浪》视频短片跟朋友圈里的那些光鲜亮丽的美景、美照差不多，让人倍感羡慕。但那毕竟是朋友圈，跟生活没有多大关系。”</p>
<p>所以，抱歉，这碗心灵鸡汤真的咽不下去！</p>
<p>第一，站错立场，说话方式不对</p>
<p>首先，在中国传统的礼仪文化中，素有尊师重道的传统美德。首先是因为尊重老人是基本的礼仪，其次是因为长辈是年轻人的“导师”，其人生的阅历和生活经验都比年轻人要丰富，常言道“不听老人言，吃亏在眼前”，说的不过如此。</p>
<p>不过，都说“面子是别人给的”，作为长者，虽然享有这样的礼仪待遇，但这并代表着他能够随心所欲。</p>
<p>演讲，作为一种公开的，面对大众的宣传讲话，却全程都以长者的身份来说理，这容易给人一种凌驾于普通大众之上的感觉。视频中，主讲者何冰以“前浪”先锋的视角来阐述对年轻人的看法，给人的感觉便是如此，这会让一些人感到不适。</p>
<p>如视频中开头所言：“那些口口声声，一代不如一代的人，应该看着你们，像我一样……”</p>
<p>开头就以老前辈的身份娓娓道来，给人一种暗喻：“嘿，我比你年长，比你更明白人世间……年轻人应该好好听着。”</p>
<p>现如今，随着时代的发展，思想的解放，年轻人，更强调个性追求，也更强调彼此之间的平等对话，即便是存在辈分之差，也亦如此。</p>
<p>而说教，是一种最让人难以接受的劝告方式。人人都有排斥说教的心理，而这点在年轻人身上表现得淋漓尽致，年轻人向来不喜欢他人以长辈的身份说事。</p>
<p>第二，贬低了年轻人自身的努力</p>
<p>首先，现在不少人对年轻人的评价是：“垮掉的一代”，因为他们个性叛逆，社会责任感弱，心理承受能力低，团队意识差，信仰缺失……</p>
<p>而视频中反复提到的“一代不如一代”的话语，说得也不过如此。虽说原文不是真正的贬低之意，但是“说者无意，听者有心”，这不经意间就刺痛许多年轻人脆弱的自尊心。</p>
<p>其次，演讲中多次提到，正如：</p>
<p>“人类积攒了几千年的财富，所有的知识、见识、智慧和艺术，像是专门为你们准备的礼物。”</p>
<p>很显然，这好像是在告诉年轻人：嘿，你们比我们幸福多了，你们是含着金钥匙长大的，拥有的选择更多，资源也更多，应该珍惜身边拥有的优越条件……</p>
<p>简言之概括：你们可以不费吹灰之力就能坐享老祖宗打下的美好天下，现在也该醒醒了，自己努力奋斗吧~</p>
<p>然而，何冰真的有错吗？</p>
<p>很显然，作为视频中的演讲者，他只是一个对外传递信息的发声者，他只是在为年轻人打气加油，他并没有错。</p>
<p>而他为何成为了众矢之的的攻击对象？很显然，他被当成了泄气的对象。</p>
<p>学者朱大可曾说：“话语暴力和秽语现象，已成中国大众文化的一种重要景观。”<br>
从诸多的网络语言暴力案件中可以看出，网络中的群体“骂街”，向来都不太分青红皂白，他们可以在短瞬间迅速站队，在群起哄或仇视心理（如仇富心态）的驱动下，对自己看不惯的人或事进行谩骂、诋毁。最终，事件就会从一小撮的网络语言暴力中，发展成了像滚雪球效应一样，越演越烈。</p>
<p>佛祖曾说：“你心中有什么，你看到的就是什么。”<br>
根据研究发现，网络语言暴力的出现更多的是源于个人自身的焦虑。所以，这就不难理解，为何《后浪》被批判为小资短片，讲述的是富家子弟的人生。毕竟，现实中，大部分人都过得挺不容易。</p>
<p>然而，短片拍得过于“高大上”，有错吗？</p>
<p>很显然，也并没有错。</p>
<p>每一个年轻人都会经历人生的“窄门”，只有停下沮丧，才能去思考，才能更好地去迎接生活的挑战。</p>
<p>人生，本来就是有苦有甜，苦是生活的一面，甜也是生活的一面。而痛苦的一面，不是用来展现给别人看的。这世间所有的痛苦都无法做到感同身受，而幸福可以。</p>
<p>励志的人生，可以激励更多的人奋勇拼搏。</p>
<p>世界之大，本应是丰富多彩的。年轻人，应该多向美好的生活看齐，向美好的生活奋勇前行。</p>
<p>奔涌吧，后浪！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《后浪》知乎的批判言论--抄录]]></title>
        <id>https://shiyuesheng.github.io/post/zhi-hu-dui-lesslesshou-lang-greatergreater-de-pi-pan-yan-lun/</id>
        <link href="https://shiyuesheng.github.io/post/zhi-hu-dui-lesslesshou-lang-greatergreater-de-pi-pan-yan-lun/">
        </link>
        <updated>2020-06-14T12:42:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>我很气愤，他们根本没有读懂后浪想表达的是什么，根本没有体会到先辈的力量，先辈的种寄托，他们说的话就像个娘们！<br>
他们的眼光太局限了，他们竟然把后浪定义成了一小撮富二代，成功人士，可笑！<br>
后浪指的是这一代人好吗。<br>
同时我也深深的体会到思想观念的冲突对立，同一个《后浪》，身为同一个国家，同一个年龄段的人，思想竟是如此的割裂，格格不入。<br>
我视若珍宝，为之感动，给我力量，让我分发的《后浪》竟被他们贬低的一文不值，甚至拿来调侃，当成了个梗，更甚之有人看到“后浪”这个词就想呕吐。<br>
我很气愤，道不同不相为谋。</p>
</blockquote>
<p>下面引用一段知乎的言论：</p>
<p>年轻人不喜欢被代表，尤其是被B站资本如此商业化的代表。<br>
朋友圈的年轻人平静如死水，从来不上B站的中老年人倒是在自嗨。<br>
带着老一代的期许和百大UP主的励志故事，演绎一段鸡汤，谄媚地送上虚伪的祝福，旨在展示自己身为“前浪”的豁达胸襟。<br>
前辈赞扬着B站编织的“后浪”，年轻人却深知视频里的“后浪”并不指自己。<br>
1、年轻人知道自己没那么牛逼。《后浪》里面的年轻人容貌俊俏，鲜衣怒马，才貌双全，要么风趣幽默，要么说话好听，年纪轻轻就成了网红达人。<br>
别说老一辈羡慕，我们年轻人也羡慕。所以达不到这个标准的人应该怎么过活呢？也去做这样一个人？<br>
去化妆打扮，去学习才艺，去国服拼命上分，去玩摄影，去拍vlog，去跳伞摄影，去周游世界？<br>
嗯，他们确实在童年过上了不惑之年的生活，真实的享受生活。可大多数年轻人的生活并非如此。<br>
一个月要么两三千，要么五六千的工资，每天10+小时以上的工作，加班夜班，身心俱疲。<br>
每过一段时间就会迷茫就会犹豫，需要考虑未来的车子，房子，甚至的下个月房租，以及如何留住身边心爱的人。<br>
或许这就是在中国平行宇宙里存在两类年轻人。<br>
2、表面上选择更多了，实际上年轻人知道自己别无选择。<br>
年轻人没有悲伤的权利，更没有选择悲伤的权利。<br>
即便是生活的重压，我们也不敢在父母面前倾诉：你不能说负能量的话，不被允许“丧”，不被允许“佛系”，如果你这么做，那你这个年轻人就是不够热爱生活。<br>
在当下的政治正确中，虚假的年轻人：冲动、迷茫、愤怒、消解和怀疑一切权威。<br>
真正的年轻人：乐观积极、从不抱怨、为消费主义和群体认同掏空钱包、为房子和996不懈奋斗。<br>
…鼓吹兴趣个性？被资本人造景观支配的年轻人，无路可逃。<br>
时代虽然进步了，但资本主导消费主义，奴役年轻人的手段也进步了，变得高明且隐蔽。<br>
这些“景观”本体及载体，从以前电影，电视转变成手机，APP和电脑，他们无孔不入，所有人都难以逃脱：看到电视剧中的求婚剧情，就认定求婚时有求婚钻戒才有仪式感；<br>
3、年轻人是知道《后浪》这玩意不是拍给自己看的。<br>
这时代诚然是个好时代，但不能被一句“我们在同一条奔涌的河流”掩盖。<br>
视频里的出国旅游，滑雪，上海陆家嘴航拍，cos表演，汉服，各种炫酷的电竞运动，不是每一个中国家庭都能承受的起的。<br>
身处广阔乡野、城镇、农村的孩子，哪里享受过这些？这是个好时代，这也是个割裂的时代。<br>
在这个营销视频中，“后浪”传达的标准是：去英国法国日本拍VLOG/B站拥有十万以上粉丝/能租私人飞机玩跳伞/拥有数套正版JK或汉服/在国际电竞比赛拿下大奖。<br>
资本为了赢得主流主旋律的认可，不遗余力的营造“真实且优秀的年轻人”。<br>
但却刻意忽略了当下普通年轻人的真实现状。<br>
在诸多媒体的口中：<br>
他/她们是一群每天睡醒就只知道忙碌工作、休息日就宅在家里点外卖的loser；<br>
他/她们是一群不会赚钱智商不高情商也一般的庸人；<br>
他/她们是一群来自普通家庭、对未来迷茫、在大城市屡屡碰壁的落魄青年；<br>
他/她们是一群为了守住心爱之人、每天拼命挣钱、焦虑房子车子首付的穷逼；</p>
<p>他们是当代年轻人中的大多数，画面声音却被资本淹没阉割，只因为他们不是合格的“后浪”。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《后浪》读后感]]></title>
        <id>https://shiyuesheng.github.io/post/lesslesshou-lang-greatergreater-du-hou-gan/</id>
        <link href="https://shiyuesheng.github.io/post/lesslesshou-lang-greatergreater-du-hou-gan/">
        </link>
        <updated>2020-06-14T08:45:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>抄录：<br>
《后浪》bilibili献给新一代的演讲<br>
2020年5月4日<br>
演讲者：何冰</p>
<p>那些口口声声，一代不如一代的人，<br>
应该看着你们，像我一样<br>
我看着你们，<br>
------满怀羡慕。</p>
<p>人类积攒了几千年的财富，<br>
所有的知识、见识、智慧和艺术，<br>
像是专门为你们准备的礼物。</p>
<p>科技繁荣，文化繁茂，城市繁华，<br>
现代文明的成果，被层层打开，可以尽情的享用，<br>
自由学习一门语言，<br>
学习一门手艺，<br>
欣赏一部电影，<br>
去遥远的地方旅行。</p>
<p>很多人，从小你们就在自由探索自己的兴趣，<br>
很多人，在童年就进入了不惑之年，<br>
不惑于自己喜欢什么，不喜欢什么。</p>
<p>人与人之间的壁垒被打破，<br>
你们只凭相同的爱好，<br>
就能结交千万个值得干杯的朋友，<br>
你们拥有了，我们曾经梦寐以求的权利 ，<br>
------选择的权利。</p>
<p>你所热爱的，就是你的生活！<br>
你们有幸遇见这样的时代，<br>
但是时代更有幸，遇见这样的你们！<br>
我看着你们，<br>
------满怀敬意。</p>
<p>向你们的专业态度致敬！你们正在：<br>
把传统的变成现代的，<br>
把经典的变成流行的，<br>
把学术的变成大众的，<br>
把名族的变成世界的，<br>
你们把自己的热爱，<br>
变成了一个和成千上万的人分享快乐的事业！</p>
<p>向你们的自信致敬！<br>
弱小的人，才习惯嘲讽与否定！<br>
内心强大的人，从不吝啬赞美与鼓励！</p>
<p>向你们的大气致敬！<br>
小人同而不和！<br>
君子美美与共，和而不同！</p>
<p>更年轻的身体，容得下更多元的文化，审美和价值观！<br>
有一天我终于发现，不止是我们在教你们如何生活，<br>
你们也在启发我们，怎样去更好的生活。</p>
<p>那些抱怨一代不如一代的人，<br>
应该看看你们，<br>
就像我一样，<br>
我看着你们，<br>
------满怀感激。</p>
<p>因为你们，<br>
这个世界会更喜欢中国。</p>
<p>因为一个国家最好看的风景，<br>
就是这个国家的年轻人。</p>
<p>因为你们这世上的小说、音乐、电影所表现的青春，<br>
就不再是忧伤、迷茫，<br>
而是善良、勇敢、无私、无所畏惧！</p>
<p>是心里有火，眼里有光！</p>
<p>不用活成我们想象中的样子，<br>
我们这一代人的想象力不足以想象你们的未来！</p>
<p>如果你们依然需要我们的祝福，</p>
<p>那么...</p>
<p>奔涌吧！后浪！</p>
<p>我们在同一条奔涌的河流！</p>
<p>加油！表达自我！拥抱世界！</p>
</blockquote>
<p>2020年5月3日 北京<br>
在疫情稍微缓和的空闲时间，我同好友去奥林匹克公园游玩了一天，算是赶了踏青的一个晚集。<br>
回到家中，洗净一天的疲乏之后，我找了个舒服的躺姿，开始愉快的刷bilibili。映入眼帘的顶部热推是什么《后浪·bilibili献给新一代的演讲》。嗨，定是什么心灵鸡汤，颓废如我，身子骨早就经不起什么补品了，刷刷美食区，舞蹈区，游戏区，动漫区，它不香吗？</p>
<p>但是但是，再不想看，也经不起b站的反复推送啊，不得不说现在的流量入侵真是粗暴--（不想看？不存在的，我呼你脸上，看清了吗？），得了，看看无妨，<a href="https://www.bilibili.com/video/BV1FV411d7u7?from=search&amp;seid=2475103027001138476"><strong>点击观看</strong></a></p>
<p>观看ing ing ing...</p>
<p>呼儿～说的太好了，真是太好了，看完之后，我内激动的热血沸腾，里面的每一句话都想是一柄奔涌的锤子在敲打这我。我看了一遍又一遍，读着满屏积极向上的弹幕，我不禁感叹国家的强大，民族的凝聚力，我仿佛被一团如水温暖包裹，那一刻我分不清是否留下了泪水...</p>
<p>思绪稳定之后，我开始细细品味里面的每段话，是哪里引起了我的共鸣，我要把这一刻的体会记录下来！</p>
<blockquote>
<p>人类积攒了几千年的财富，<br>
所有的知识、见识、智慧和艺术，像是专门为你们准备的礼物。<br>
科技繁荣，文化繁茂，城市繁华，<br>
现代文明的成果，被层层打开，可以尽情的享用。</p>
</blockquote>
<p>是啊，现在是一个信息化的时代，在b站可以可以找到任何你想看的东西，游戏、动漫、电影、音乐、舞蹈、美食、旅游鬼畜、法治...等等 等等，这在以前是不敢现象的。<br>
学习的门槛降低了，在b站可以找到很多课程的分享、技术总结，还有世界名校哈弗、剑桥的公开课，你可以体验一把跟世界精英一同上课，你不禁赞叹他们的优秀。</p>
<blockquote>
<p>人与人之间的壁垒被打破，你们只凭相同的爱好，<br>
就能结交千万个值得干杯的朋友，<br>
你们拥有了，我们曾经梦寐以求的权利 ，<br>
------选择的权利。</p>
</blockquote>
<p>你可以因为热爱一个游戏结识天南海北的朋友，因为喜欢古典音乐跟一群人陶醉在音乐的海洋里，因为喜欢洛天依，发现你不是孤独的，有一群人在为洛天依谱写新的歌曲。。。</p>
<blockquote>
<p>你所热爱的，就是你的生活！<br>
你们有幸遇见这样的时代，<br>
但是时代更有幸，遇见这样的你们！</p>
</blockquote>
<p>什么是生活？<br>
你所热爱的，就是你的生活！<br>
我还想加一句，<br>
你所守护的，就是你的生活！</p>
<blockquote>
<p>向你们的自信致敬！<br>
弱小的人，才习惯嘲讽与否定！<br>
内心强大的人，从不吝啬赞美与鼓励！</p>
<p>向你们的大气致敬！<br>
小人同而不和！<br>
君子美美与共，和而不同！</p>
</blockquote>
<p>这里引用鲁迅的一句话：<br>
愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。<br>
能做事的做事，能发声的发声。<br>
有一分热，发一分光。就令萤火一般，也可以在黑暗里发一点光，不必等候炬火</p>
<blockquote>
<p>因为你们，<br>
这个世界会更喜欢中国。</p>
<p>因为一个国家最好看的风景，<br>
就是这个国家的年轻人。</p>
<p>因为你们这世上的小说、音乐、电影所表现的青春，<br>
就不再是忧伤、迷茫，<br>
而是善良、勇敢、无私、无所畏惧！</p>
<p>是心里有火，眼里有光！</p>
<p>不用活成我们想象中的样子，<br>
我们这一代人的想象力不足以想象你们的未来！</p>
</blockquote>
<p>世界属于年轻人的，国家属于年轻人的<br>
这个国家的年轻人是什么样的，这个国家就是什么样的。</p>
<p>我希望国家是强大的，是崛起的，再次站在世界之巅。<br>
所以我希望我是热血的，激情的，拼搏的。<br>
这玩鸡汤真香，干了！</p>
<p>其实在感叹这个时代的美好，表达自我，拥抱世界之外，我还深深感受到了辛酸<br>
辛酸来自哪里？来自现在的一切是如何缔造的？<br>
是先辈们用百年的变革换来的！是先辈一代人的一生！是先辈一代人无悔的青春！<br>
他们劈荆斩棘，筚路蓝缕，趟过了大雪山，迎着枪林弹雨，用血肉之躯换来的！<br>
是他们奉献了青春和热血，建立了我们的祖国！建设了我们的祖国！<br>
现在所有的一切，都是先辈们的恩惠、寄托。<br>
不需要说谢谢，他们就是我们的长辈，我们是他们的孩子。</p>
<p>心怀感恩！<br>
活出精彩！</p>
<p>此生不悔入华夏，来世还生种花家！</p>
<blockquote>
<p>奔涌吧！阿声！<br>
奔涌吧！朵朵！</p>
</blockquote>
]]></content>
    </entry>
</feed>